#!/usr/bin/env python
# encoding: utf-8
'''
check_transcriptor_regulators -- shortdesc

check_transcriptor_regulators is a description

It defines classes_and_methods

@author:     user_name

@copyright:  2022 organization_name. All rights reserved.

@license:    license

@contact:    user_email
@deffield    updated: Updated
'''

import sys
import os, re, glob
import optparse

from utils.util import Utils
from constants.constants import Constants
from utils.util import TransFactors
from process.process_files import ProcessGFF

__all__ = []
__version__ = 0.1
__date__ = '2022-11-07'
__updated__ = '2022-11-07'

DEBUG = 1
TESTRUN = 0
PROFILE = 0

utils = Utils()
constants = Constants()


def checkRequiredArguments(opts, parser):
	missing_options = []
	for option in parser.option_list:
		if re.match(r'^\[REQUIRED\]', option.help) and eval('opts.' + option.dest) == None:
			missing_options.extend(option._long_opts)
		if len(missing_options) > 0:
			parser.error('Missing REQUIRED parameters: ' + str(missing_options))

# $ module load samtools htslib bcftools mafft
def main(argv=None):
	'''Command line options.'''

	"""
	rna_coding_R64-2-1_20150113.fasta, file
	Main path: /home/projects/ua/goncalo_sousa_phd
	python3 ~/git/transcriptionalRegulatorsVCF/check_transcriptor_regulators.py --in yeastract.fasta --vcf vcf --reference_fasta C_albicans_SC5314_A22_chromosomes.fasta -a C_albicans_SC5314_A22_current_features_only_As.gff -o result_data
	"""

	class MyParser(optparse.OptionParser):
		def format_epilog(self, formatter):
			return self.epilog

	program_name = os.path.basename(sys.argv[0])
	program_version = "v0.2"
	program_build_date = "%s" % __updated__

	program_version_string = '%%prog %s (%s)' % (program_version, program_build_date)
	#program_usage = '''usage: spam two eggs''' # optional - will be autogenerated by optparse
	program_longdesc = '''
$ module load coverage_from_bam
$ python3 ~/git/transcriptionalRegulatorsVCF/check_transcriptor_regulators.py --in yeastract.fasta --vcf vcf --reference_fasta C_albicans_SC5314_A22_chromosomes.fasta -a C_albicans_SC5314_A22_current_features_only_As.gff -o result_data

'''

	program_license = "Copyright 2019 user_name (Universidade de Aveiro)											\
				Licensed under the Apache License 2.0\nhttp://www.apache.org/licenses/LICENSE-2.0"

	if argv is None:
		argv = sys.argv[1:]
	
	# setup option parser
	
	parser = MyParser(version=program_version_string, epilog=program_longdesc, description=program_license)
	parser.add_option("-i", "--in", dest="infile", help="[REQUIRED] Transcription factors (fasta)", metavar="FILE")
	parser.add_option("-p", "--vcf", dest="vcf", help="[REQUIRED] set input path with VCF samples", metavar="FILE")
	parser.add_option("-r", "--reference_fasta", dest="reference_fasta", help="[REQUIRED] input fasta (reference)", metavar="FILE")
	parser.add_option("-a", "--annotation_file_gff", dest="annotation_file_gff", help="[REQUIRED] input gff (annotation), look gor genes", metavar="FILE")
	parser.add_option("-w", "--windown_size", dest="windown_size",
			help="Size of windows to analyse. Where the transcription factors are going to bind.",
			default=1000)
	parser.add_option("-o", "--out", dest="outfile", help="[REQUIRED] set output path", metavar="FILE")
	parser.add_option("-s", "--sample_list", dest="sample_list", help="list of sample to order de output", metavar="FILE")
	parser.add_option("-g", "--gene_list", dest="gene_list", help="list of gene names to process. If empty process all", metavar="FILE")
	
	# process options
	(opts, args) = parser.parse_args(argv)
	checkRequiredArguments(opts, parser)

	## show help and epilog
	if hasattr(opts, 'help') and opts.help:
		parser.print_help()
		sys.exit()

	if opts.windown_size is None: opts.windown_size = 1000
	if opts.infile:              print("infile Transcriptor Factors  %s" % opts.infile)
	if opts.reference_fasta:     print("reference file               %s" % opts.reference_fasta)
	if opts.annotation_file_gff: print("annotation_file_gff          %s" % opts.annotation_file_gff)
	if opts.vcf:                 print("path_in (with vcf)           %s" % opts.vcf)
	if opts.outfile:             print("outfile                      %s" % opts.outfile)
	if opts.windown_size:        print("windown_size                 %s" % opts.windown_size)
	if opts.sample_list:         print("sample_list                  %s" % opts.sample_list)
	if opts.gene_list:           print("gene_list                    %s" % opts.gene_list)

	### test file exist
	utils.test_file_exists(opts.infile)
	utils.test_file_exists(opts.reference_fasta)
	utils.test_file_exists(opts.annotation_file_gff)
	utils.test_file_exists(opts.vcf)
	if not opts.sample_list is None: utils.test_file_exists(opts.sample_list)
	if not opts.gene_list is None: utils.test_file_exists(opts.gene_list)
	
	### read transfactors
	read_factors = TransFactors(opts.infile)
	process_files = ProcessGFF(read_factors, opts.sample_list)
	
	## get all vcf files
	list_vcf_files = list(glob.glob(os.path.join(opts.vcf, "*.vcf.gz")))
	if len(list_vcf_files) == 0:
		sys.exit("Error: there's no vcf.gz files in that path - " + opts.path_in)

	### list of genes to process
	#lst_genes_to_process = ['C4_00010W_A']
	lst_genes_to_process = []
	if not opts.gene_list is None:
		lst_genes_to_process = utils.read_text_file(opts.gene_list)
		print("Number of genes to process: {}".format(len(lst_genes_to_process)))
	
	
	## process all data
	size_window = 1000
	process_files.process_gff(opts.reference_fasta, opts.annotation_file_gff, list_vcf_files, size_window,
				opts.outfile, dict(zip(lst_genes_to_process, [1] * len(lst_genes_to_process))),
				size_window )
	print("Done")


if __name__ == "__main__":
	sys.exit(main())
	
